double test_swapMachinePair(){
		vector<double> newFinishTimes;
		vector<double> newStartTimes;

		double originalCost = this->calculateMakespam();

		vector<int> allocations = vector<int>(files.size(), -1);
		for(int f = 0; f < files.size(); f++){
			int id = files[f]->alocated_vm_id;
			allocations[files[f]->id] = id;
		}

		for(int pos = 0; pos < this->alloc.size(); pos++){ // SWAP MACHINE LOOP START
			Allocation * swap = this->alloc[pos];
			Job * job = swap->job;
			Machine * originalAllocationMachine = swap->vms;

			int posOnTimeline = originalAllocationMachine->jobPosOnTimeline(job->id);
			double oldExecTime = originalAllocationMachine->timelineFinishTime[posOnTimeline] - originalAllocationMachine->timelineStartTime[posOnTimeline];

			int write_vm_id = swap->writeTo;

			for(int pos2 = pos + 1; pos2 < this->alloc.size(); pos2++){
				
				Allocation * swap2 = this->alloc[pos2];
				Job * job2 = swap2->job;
				Machine * originalAllocationMachine2 = swap2->vms;

				// cout << "JobID: " << job->id << " Job2ID: " << job2->id << endl;

				int posOnTimeline2 = originalAllocationMachine2->jobPosOnTimeline(job2->id);
				double oldExecTime2 = originalAllocationMachine2->timelineFinishTime[posOnTimeline2] - originalAllocationMachine2->timelineStartTime[posOnTimeline2];

				int write_vm_id2 = swap2->writeTo;

				// times for pos job
				Machine * testVm = swap2->vms;
				double readtime = calculateReadtime(job, testVm->id);

				// double writetime = calculateWritetimeWithChanges(job, testVm->id, allocations);
				double writetime = calculateWritetime(job, testVm->id, write_vm_id);

				double processtime = ceil(job->base_time * testVm->slowdown);

				double newTime = readtime + processtime + writetime;

				// times for pos2 job
				testVm = swap->vms;
				readtime = calculateReadtime(job2, testVm->id);

				// writetime = calculateWritetimeWithChanges(job2, testVm->id, allocations);

				writetime = calculateWritetime(job, testVm->id, write_vm_id2);

				processtime = ceil(job2->base_time * testVm->slowdown);

				double newTime2 = readtime + processtime + writetime;


				newFinishTimes = vector<double>(this->jobs.size(), 0.0);
				newStartTimes = vector<double>(this->jobs.size(), 0.0);
				// int allocPos, int allocPos2, Job* job, Job* job2, double newTime, double newTime2, vector<double> &newStartTimes, vector<double> &newFinishTimes
				double newSpan = calculate_swapMachinePair_effect(pos, pos2, job, job2, newTime, newTime2, newStartTimes, newFinishTimes);
				// cout << "JOBID: " << job->id << " i: " << i << " span: " << newSpan << " originalSpan: " << originalCost<< " readtime: " << readtime << " processtime: " << processtime << " writetime: " << writetime << endl;

				// cout << "originalCost: " << originalCost << " newSpan: " << newSpan << " oldExecTime: " << oldExecTime << " newTime: " << newTime << " machinePos: " << i << endl;
				// cin.get();
				if(newSpan < originalCost){
					// cout << "The new Span is: " << originalCost - oldExecTime + newTime << endl;
					
					// cin.get();
					return this->execSwapMachinePair(pos, pos2, newStartTimes, newFinishTimes);
				}
				
			}
		}
		return -1;
	}

	double execSwapMachinePair(int pos, int pos2, vector<double>& newStartTimes, vector<double>& newFinishTimes){
		Job * changedJob = this->alloc[pos]->job;
		Machine * changedVm = this->alloc[pos2]->vms;
		Job * changedJob2 = this->alloc[pos2]->job;
		Machine * changedVm2 = this->alloc[pos]->vms;
		for(int a = 0; a < this->alloc.size(); a++){
			Job * job = this->alloc[a]->job;
			Machine * vm = this->alloc[a]->vms;
			int posOnTimeline = vm->jobPosOnTimeline(job->id);

			if(job->id == changedJob->id){
				// cout << "Is Changed Job!" << endl;
				job->alocated_vm_id = changedVm->id;
				vm->timelineJobs.erase(vm->timelineJobs.begin() + posOnTimeline);
				vm->timelineStartTime.erase(vm->timelineStartTime.begin() + posOnTimeline);
				vm->timelineFinishTime.erase(vm->timelineFinishTime.begin() + posOnTimeline);
				// cout << "Erased" << endl;

				// this->print();
				// cin.get();

				bool inserted = false;

				// cout << "Changed VM ID: " << changedVm->id << endl;
				for(int j = 0; j < changedVm->timelineJobs.size(); j++){
					// cout << "j: " << j << endl;
					int jId = changedVm->timelineJobs[j]->id;
					if(newStartTimes[jId] >= newFinishTimes[job->id]){
						// cout << "Found possition: " << j << endl;
						changedVm->timelineJobs.insert(changedVm->timelineJobs.begin() + j, job);
						changedVm->timelineStartTime.insert(changedVm->timelineStartTime.begin() + j, newStartTimes[job->id]);
						changedVm->timelineFinishTime.insert(changedVm->timelineFinishTime.begin() + j, newFinishTimes[job->id]);
						inserted=true;
						break;
					}
				}
				if(!inserted){
					changedVm->timelineJobs.push_back(job);
					changedVm->timelineStartTime.push_back(newStartTimes[job->id]);
					changedVm->timelineFinishTime.push_back(newFinishTimes[job->id]);
				}
			

			} else if(job->id == changedJob2->id){
				job->alocated_vm_id = changedVm2->id;
				vm->timelineJobs.erase(vm->timelineJobs.begin() + posOnTimeline);
				vm->timelineStartTime.erase(vm->timelineStartTime.begin() + posOnTimeline);
				vm->timelineFinishTime.erase(vm->timelineFinishTime.begin() + posOnTimeline);
				// cout << "Erased" << endl;

				// this->print();
				// cin.get();

				bool inserted = false;

				// cout << "Changed VM ID: " << changedVm->id << endl;
				for(int j = 0; j < changedVm2->timelineJobs.size(); j++){
					// cout << "j: " << j << endl;
					int jId = changedVm2->timelineJobs[j]->id;
					if(newStartTimes[jId] >= newFinishTimes[job->id]){
						// cout << "Found possition: " << j << endl;
						changedVm2->timelineJobs.insert(changedVm2->timelineJobs.begin() + j, job);
						changedVm2->timelineStartTime.insert(changedVm2->timelineStartTime.begin() + j, newStartTimes[job->id]);
						changedVm2->timelineFinishTime.insert(changedVm2->timelineFinishTime.begin() + j, newFinishTimes[job->id]);
						inserted=true;
						break;
					}
				}
				if(!inserted){
					changedVm2->timelineJobs.push_back(job);
					changedVm2->timelineStartTime.push_back(newStartTimes[job->id]);
					changedVm2->timelineFinishTime.push_back(newFinishTimes[job->id]);
				}
			
			} else{
				// cout << "Regular Job" << endl;
				vm->timelineFinishTime[posOnTimeline] = newFinishTimes[job->id];
				vm->timelineStartTime[posOnTimeline] = newStartTimes[job->id];
			}
		}

		this->alloc[pos]->vms = changedVm;
		this->alloc[pos2]->vms = changedVm2;

		// this->calculateMakespam();
		// this->print();

		// this->checkFeasible();
		// cin.get();

		return this->calculateMakespam();
	}

	double calculate_swapMachinePair_effect(int allocPos, int allocPos2, Job* job, Job* job2, double newTime, double newTime2, vector<double> &newStartTimes, vector<double> &newFinishTimes){
		for(int a = 0; a < alloc.size(); a++){ // preenchendo inicio e fim original
			int jobId = alloc[a]->job->id;
			Machine * vm = alloc[a]->vms;
			int posOnVm = vm->jobPosOnTimeline(jobId);
			newStartTimes[jobId] = vm->timelineStartTime[posOnVm];
			newFinishTimes[jobId] = vm->timelineFinishTime[posOnVm];
		}

		int vmId = alloc[allocPos2]->vms->id;
		int vmId2 = alloc[allocPos]->vms->id;

		// procurar latest job na vmId e latest job que tenha conflito 
		double latestJobVmFinish =  0.0;
		double latestJobConflictFinish = 0.0;
		for(int a = 0; a < allocPos; a++){
			if(conflicts[job->id][alloc[a]->job->id] == 0){ // nao tem conflito
				if(alloc[a]->vms->id == vmId){ // esta na mesma maquina
					if(newFinishTimes[alloc[a]->job->id] > latestJobVmFinish) // terminou mais tarde do que o ultimo da mesma vm
						latestJobVmFinish = newFinishTimes[alloc[a]->job->id];
				}
			} else{ // tem conflito
				if(newFinishTimes[alloc[a]->job->id] > latestJobConflictFinish) // terminou mais tarde do que o ultimo que tenha conflito
					latestJobConflictFinish = newFinishTimes[alloc[a]->job->id];
			}
		}
		newStartTimes[alloc[allocPos]->job->id] = max(latestJobVmFinish, latestJobConflictFinish); // tempo de comeco
		newFinishTimes[alloc[allocPos]->job->id] = newStartTimes[alloc[allocPos]->job->id] + newTime; // tempo de fim

		// printAlloc();

		// cout << "######################" << endl;
		// for(int i = 0; i < newStartTimes.size(); i++){
		// 	// if(jobs[i]->alocated_vm_id == job->alocated_vm_id)
		// 		cout << "Id: " << i << " Start: " << newStartTimes[i] << " Finish: " << newFinishTimes[i] << endl;
		// }


		for(int a = allocPos + 1; a < alloc.size(); a++){ // recalculando start e finish seguindo a ordem de allocation
			if(a == allocPos2){
				latestJobVmFinish =  0.0;
				latestJobConflictFinish = 0.0;
				for(int a = 0; a < allocPos2; a++){
					if(conflicts[job2->id][alloc[a]->job->id] == 0){ // nao tem conflito
						int id = alloc[a]->vms->id;
						if (a == allocPos) id = vmId;
						if(id == vmId2){ // esta na mesma maquina
							// cout << "Mesma Maquina! ID: " << alloc[a]->job->id << endl;
							if(newFinishTimes[alloc[a]->job->id] > latestJobVmFinish) // terminou mais tarde do que o ultimo da mesma vm
								latestJobVmFinish = newFinishTimes[alloc[a]->job->id];
						}
					} else{ // tem conflito
						if(newFinishTimes[alloc[a]->job->id] > latestJobConflictFinish) // terminou mais tarde do que o ultimo que tenha conflito
							latestJobConflictFinish = newFinishTimes[alloc[a]->job->id];
					}
				}
				newStartTimes[alloc[allocPos2]->job->id] = max(latestJobVmFinish, latestJobConflictFinish); // tempo de comeco
				newFinishTimes[alloc[allocPos2]->job->id] = newStartTimes[alloc[allocPos2]->job->id] + newTime2; // tempo de fim
			}
			else{
				latestJobConflictFinish = 0.0;
				latestJobVmFinish = 0.0;
				int aPosOnVm = alloc[a]->vms->jobPosOnTimeline(alloc[a]->job->id);
				
				double execTime = alloc[a]->vms->timelineFinishTime[aPosOnVm] - alloc[a]->vms->timelineStartTime[aPosOnVm];
				for(int b = 0; b < a; b++){
					int bPosOnVm = alloc[b]->vms->jobPosOnTimeline(alloc[b]->job->id);
					int bVmId = alloc[b]->vms->id;
					if(b == allocPos){ // eh o modificado
						bVmId = vmId;
					} else if(b == allocPos2){
						bVmId = vmId2;
					}
					if(conflicts[alloc[a]->job->id][alloc[b]->job->id] == 0){ // nao tem conflito
						if(alloc[a]->vms->id == bVmId){ // esta na mesma maquina
							if(newFinishTimes[alloc[b]->job->id] > latestJobVmFinish) // terminou mais tarde do que o ultimo da mesma vm
								latestJobVmFinish = newFinishTimes[alloc[b]->job->id];
						}
					} else { // tem conflito
						if(newFinishTimes[alloc[b]->job->id] > latestJobConflictFinish) // terminou mais tarde do que o ultimo que tenha conflito
							latestJobConflictFinish = newFinishTimes[alloc[b]->job->id];
					}
				}
				newStartTimes[alloc[a]->job->id] = max(latestJobVmFinish, latestJobConflictFinish); // tempo de comeco
				newFinishTimes[alloc[a]->job->id] = newStartTimes[alloc[a]->job->id] + execTime; // tempo de fim
			}
		}


		// cout << "**************************" << endl;
		// for(int i = 0; i < newStartTimes.size(); i++){
		// 	// if(jobs[i]->alocated_vm_id == job->alocated_vm_id)
		// 		cout << "Id: " << i << " Start: " << newStartTimes[i] << " Finish: " << newFinishTimes[i] << endl;
		// }
		// cin.get();

		double biggestSpan = 0.0;
		for(int i = 0; i < newFinishTimes[i]; i++){
			if(newFinishTimes[i] > biggestSpan)
				biggestSpan = newFinishTimes[i];
		}

		return biggestSpan;
	}
	
	
	
	
	
	
	***************************
	
	
	
	double test_swapFileAllocation(){
		vector<double> newFinishTimes;
		vector<double> newStartTimes;
		for(int f = 0; f < this->files.size(); f++){
			Item * file = files[f];
			// cout << "File: " << file->id << " is_Static: " << file->is_static << endl;
			if(file->is_static) continue;

			double originalCost = this->calculateMakespam();
			double bestMove = originalCost;
			int bestId = -1;
			for(unsigned int i = 0; i < this->vms.size(); i++){
				Machine * testVm = this->vms[i];
				// cout << "Tested VM: " << testVm->id << endl;

				if(testVm->id == file->alocated_vm_id) continue;
				
				newFinishTimes = vector<double>(this->jobs.size(), 0.0);
				newStartTimes = vector<double>(this->jobs.size(), 0.0);

				double newSpan = calculate_swapFileAllocation_Effect(file, testVm->id, newStartTimes, newFinishTimes);
				// cout << "JOBID: " << job->id << " i: " << i << " span: " << newSpan << " originalSpan: " << originalCost<< " readtime: " << readtime << " processtime: " << processtime << " writetime: " << writetime << endl;

				// cout << "originalCost: " << originalCost << " newSpan: " << newSpan << " machinePos: " << i << endl;
				// cin.get();
				if(newSpan < bestMove){
					// cout << "The new Span is: " << newSpan << " was: " << originalCost << endl;
					// cout << "File: " << file->id << " is_Static: " << file->is_static << " Tested VM: " << testVm->id << endl;
					// cin.get();
					bestMove = newSpan;
					bestId = testVm->id;
				}
			}
			if(bestId >= 0){
				return this->execSwapFileAllocation(file, bestId, newStartTimes, newFinishTimes);
			}
		}
		cout << "Nao achou melhora!" << endl;
		return -1.0;
	}
	double calculate_swapFileAllocation_Effect(Item * file, int writeTo, vector<double>& newStartTimes, vector<double>& newFinishTimes){
		
		for(int a = 0; a < alloc.size(); a++){ // preenchendo inicio e fim original
			int jobId = alloc[a]->job->id;
			Machine * vm = alloc[a]->vms;
			int posOnVm = vm->jobPosOnTimeline(jobId);
			newStartTimes[jobId] = vm->timelineStartTime[posOnVm];
			newFinishTimes[jobId] = vm->timelineFinishTime[posOnVm];
		}

		vector<int> newAlocations = vector<int>(files.size(), -1);
		vector<int> oldAlocations = vector<int>(files.size(), -1);
		for(int f = 0; f < files.size(); f++){
			int id = files[f]->alocated_vm_id;
			oldAlocations[files[f]->id] = id;
			if(files[f]->id == file->id) id = writeTo;
			newAlocations[files[f]->id] = id;
		}
		// for(int i = 0; i < newStartTimes.size(); i++){
		// 	// if(jobs[i]->alocated_vm_id == job->alocated_vm_id)
		// 		cout << "Id: " << i << " Start: " << newStartTimes[i] << " Finish: " << newFinishTimes[i] << endl;
		// }

		double latestJobConflictFinish = 0.0;
		double latestJobVmFinish = 0.0;

		for(int a = 0; a < alloc.size(); a++){ // recalculando start e finish seguindo a ordem de allocation
			latestJobConflictFinish = 0.0;
			latestJobVmFinish = 0.0;
			int aPosOnVm = alloc[a]->vms->jobPosOnTimeline(alloc[a]->job->id);
			double oldWriteTime = calculateWritetimeWithChanges(alloc[a]->job, alloc[a]->vms->id, oldAlocations);
			double oldReadTime = calculateReadtime(alloc[a]->job, alloc[a]->vms->id);
			double execTime = alloc[a]->vms->timelineFinishTime[aPosOnVm] - alloc[a]->vms->timelineStartTime[aPosOnVm] - oldReadTime - oldWriteTime;			
			
			double readTime = 0.0;

			for(int f = 0; f < alloc[a]->job->input.size(); f++){
				int minBandwidthVm = alloc[a]->vms->id;
				if(alloc[a]->job->input[f]->is_static){
					bool transferNeed = true;
					double maxBandwidth = 0.0;
					int id;
					for(int j = 0; j < alloc[a]->job->input[f]->static_vms.size(); j++){
						if(alloc[a]->vms->id == alloc[a]->job->input[f]->static_vms[j]){
							transferNeed = false;
							break;
						}
						if(alloc[a]->job->input[f]->VMsBandwidth[alloc[a]->job->input[f]->static_vms[j]] > maxBandwidth){
							maxBandwidth = alloc[a]->job->input[f]->VMsBandwidth[alloc[a]->job->input[f]->static_vms[j]];
							id = alloc[a]->job->input[f]->static_vms[j];
						}
					}

					if(maxBandwidth < alloc[a]->job->input[f]->VMsBandwidth[alloc[a]->vms->id])
						minBandwidthVm = id;
					if(transferNeed) readTime += alloc[a]->job->input[f]->IOTimeCost[minBandwidthVm];
				} else{
					// cout << "Not Static!" << endl;
					Item * auxFile = alloc[a]->job->input[f];
					int origin = auxFile->alocated_vm_id;
					
					if(file->id == auxFile->id) origin = writeTo;

					if(origin == alloc[a]->vms->id) continue;

					if(alloc[a]->job->input[f]->VMsBandwidth[origin] < alloc[a]->job->input[f]->VMsBandwidth[minBandwidthVm])
						minBandwidthVm = origin;
					// cout << "ReadTime += " <<  alloc[a]->job->input[f]->IOTimeCost[minBandwidthVm] << endl;
					readTime += alloc[a]->job->input[f]->IOTimeCost[minBandwidthVm];
				}
			}

			double writeTime = calculateWritetimeWithChanges(alloc[a]->job, alloc[a]->vms->id, newAlocations);

			// cout << "execTime: " << execTime + calculateReadtime(alloc[a]->job, alloc[a]->vms->id) << " oldRead: " << calculateReadtime(alloc[a]->job, alloc[a]->vms->id);			

			execTime += readTime + writeTime;

			// cout << "FileID: " << file->id << " newWriteTo: " << writeTo << " newRead: " << readTime << " oldRead: " << oldReadTime <<  " newWrite: " << writeTime << " oldWrite: " << oldWriteTime <<" newExec: " << execTime << endl;


			for(int b = 0; b < a; b++){
				int bPosOnVm = alloc[b]->vms->jobPosOnTimeline(alloc[b]->job->id);
				int bVmId = alloc[b]->vms->id;
				if(conflicts[alloc[a]->job->id][alloc[b]->job->id] == 0){ // nao tem conflito
					if(alloc[a]->vms->id == bVmId){ // esta na mesma maquina
						if(newFinishTimes[alloc[b]->job->id] > latestJobVmFinish) // terminou mais tarde do que o ultimo da mesma vm
							latestJobVmFinish = newFinishTimes[alloc[b]->job->id];
					}
				} else { // tem conflito
					if(newFinishTimes[alloc[b]->job->id] > latestJobConflictFinish) // terminou mais tarde do que o ultimo que tenha conflito
						latestJobConflictFinish = newFinishTimes[alloc[b]->job->id];
				}
			}
			newStartTimes[alloc[a]->job->id] = max(latestJobVmFinish, latestJobConflictFinish); // tempo de comeco
			newFinishTimes[alloc[a]->job->id] = newStartTimes[alloc[a]->job->id] + execTime; // tempo de fim
		}



		// for(int i = 0; i < newStartTimes.size(); i++){
		// 	// if(jobs[i]->alocated_vm_id == job->alocated_vm_id)
		// 		cout << "Id: " << i << " Start: " << newStartTimes[i] << " Finish: " << newFinishTimes[i] << endl;
		// }
		// cin.get();

		double biggestSpan = 0.0;
		for(int i = 0; i < newFinishTimes[i]; i++){
			if(newFinishTimes[i] > biggestSpan)
				biggestSpan = newFinishTimes[i];
		}

		return biggestSpan;
	}

	double execSwapFileAllocation(Item * file, int writeTo, vector<double>& newStartTimes, vector<double>& newFinishTimes){
		file->alocated_vm_id = writeTo;

		for(int a = 0; a < this->alloc.size(); a++){
			Job * job = this->alloc[a]->job;
			Machine * vm = this->alloc[a]->vms;
			int posOnTimeline = vm->jobPosOnTimeline(job->id);

			vm->timelineFinishTime[posOnTimeline] = newFinishTimes[job->id];
			vm->timelineStartTime[posOnTimeline] = newStartTimes[job->id];
		}
		// cout << "^^^^" << endl;
		// this->print();
		// cin.get();

		return this->calculateMakespam();
	}